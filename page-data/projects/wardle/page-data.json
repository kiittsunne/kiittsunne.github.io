{"componentChunkName":"component---src-pages-projects-mdx-frontmatter-slug-tsx-content-file-path-users-kit-code-projects-portfolio-src-pages-projects-raws-wardle-mdx","path":"/projects/wardle/","result":{"data":{"mdx":{"body":"\nimport Image from \"../../../components/img\";\nimport Gallery from \"../../../components/imageGallery\";\n\n### Project Overview\n\nWardle is a Wordle clone with a turn-based twist. The player will race against a CPU to guess a 5-letter word in 6 tries or fewer.\n\n<Image\n  src={\n    \"https://res.cloudinary.com/kiittsunne/video/upload/e_loop:10,c_scale,q_100,w_350/v1666338188/wardle_1_tqrylq.gif\"\n  }\n  alt={\"Wardle\"}\n/>\n\nUsing data attributes, I was able to build a theme-changer. In each case, the green shade still represents correctly placed letters, but the traditional yellow tiles are replaced by a theme colour.\n\n<Image\n  src={\n    \"https://res.cloudinary.com/kiittsunne/video/upload/e_loop:10,c_scale,q_100,w_350/v1666338188/wardle_2.gif\"\n  }\n  alt={\"Wardle Themes\"}\n/>\n\n<hr />\n\n### Technologies & Motivations\n\n- Vanilla HTML, CSS, JS\n\n  - JS: DOM manipulation via browser events\n  - JSON instead of API for word list\n\n- Aiming to have the game be playable on pc browser for initial version\n  - mobile browser version: might require UI re-design, will keep it simple for now.\n\nAs `Wardle` was my first project under General Assembly (GA), I took the opportunity to deepen my understanding of CSS animations and DOM manipulation techniques. I also attempted designing a 'fake AI' system, to make my Wordle clone more unique.\n\n<hr />\n\n### Retrospective: Process Notes, Key Learning Points, Future Plans\n\n#### Process notes:\n\nAt the beginning of the project week, I drafted some daily story points as a guide for my development process.\n\n<Gallery\n  images={[\n    {\n      src: \"https://res.cloudinary.com/kiittsunne/image/upload/v1666344875/website/wardle_monday.png\",\n      alt: \"Monday\",\n    },\n    {\n      src: \"https://res.cloudinary.com/kiittsunne/image/upload/v1666344877/website/wardle_tuesday.png\",\n      alt: \"Tuesday\",\n    },\n    {\n      src: \"https://res.cloudinary.com/kiittsunne/image/upload/v1666344881/website/wardle_wednesday.png\",\n      alt: \"Wednesday\",\n    },\n    {\n      src: \"https://res.cloudinary.com/kiittsunne/image/upload/v1666344886/website/wardle_thursday.png\",\n      alt: \"Thursday\",\n    },\n  ]}\n  maxWidth={\"600px\"}\n/>\n\nBecause of how straight-forward this project's goals were, and the relative simplicity of the UI, I was able to focus on the game logic.\n\n#### Key Learning Points\n\nTwo challenges in particular were highly educational experiences.\n\n**1. Synthetic Events do not bubble by default**\n\n```JavaScript\nfunction submitCpuInput(lettersArr) {\n  lettersArr.push(\"GO\");\n  let interval = 200;\n  let increment = 1;\n  let clickEvent = new Event(\"click\", { bubbles: true });\n  // sauce: https://stackoverflow.com/questions/25256535/javascript-set-interval-for-each-array-value-setinterval-array-foreach/37215055#37215055\n  for (let i = 0; i <= WORD_LENGTH; i++) {\n    let runner = setTimeout(() => {\n      document\n        .querySelector(`[data-cpu-key=\"${lettersArr[i]}\"]`)\n        .dispatchEvent(clickEvent);\n      clearTimeout(runner);\n    }, interval * increment);\n    increment++;\n  }\n}\n```\n\nTo simulate the CPU 'typing' out its answer, I dispatched events to the on-screen keyboard, simulating a player interacting with the keyboard. This eliminated the need to write unique animation logic for the CPU's side of the game.\n\nHowever, after initially writing this dispatch function, I noticed the event was not triggering. MDN's documentation was not explicit about whether `Event.bubbles` defaulted to `true` or `false`. It was only after several rounds of trial and error, and research on StackOverflow did I realise this property was the source of the problem.\n\n<br />\n\n**2. Object methods for filtering dictionary words with _all_ valid letters**\n\n```javascript\n///////////////////////////////////////////////////////////\n// CONTAINS VALID filter: shortlists words with all valid letters\nlet containsValidDuplicates = [];\nnoDupes.filter((word) => {\n  for (let i = 0; i < uniqueValid.length; i++) {\n    if (word.includes(uniqueValid[i]) == true)\n      containsValidDuplicates.push(word);\n  }\n});\nlet containsValidFrequency = {};\ncontainsValidDuplicates.forEach((word) => {\n  containsValidFrequency[word] = (containsValidFrequency[word] || 0) + 1;\n});\nlet filterValidByFrequency = Object.entries(containsValidFrequency);\nlet isolateContainsValid = filterValidByFrequency.filter(\n  (filteredWordsInArrayFormat) => {\n    if (filteredWordsInArrayFormat[1] === uniqueValid.length) {\n      return filteredWordsInArrayFormat;\n    }\n  }\n);\nlet trueValid = [];\nisolateContainsValid.forEach((wordArray) => trueValid.push(wordArray[0]));\nconsole.log(containsValidDuplicates);\n///////////////////////////////////////////////////////////\n```\n\nAs I was still relatively inexperienced with data structure manipulation and algorithms at this point in my learning process, I struggled to filter words containing all valid letters. Initially I thought I could use the `Array.includes()` method, but this produces an imperfect match. Words including some but not all, or words containing more copies of duplicate letters than what is correct, were included amongst the machine's guess list. Finally, I was able to settle on this relatively crude sorting function that utilises a hashmap.\n\n#### Future Plans\n\n**1. Refine sorting algorithm**\n\nGiven more time, I would have refactored my sorting algorithm to combine the use of a hashmap with regex functions. A pattern similar to Leetcode's [Roman to Integer Question](https://leetcode.com/problems/roman-to-integer/) comes to mind.\n\n```javascript\nvar romanToInt = function (s) {\n  const dict = {\n    IV: 4,\n    IX: 9,\n    XL: 40,\n    XC: 90,\n    CD: 400,\n    CM: 900,\n    I: 1,\n    V: 5,\n    X: 10,\n    L: 50,\n    C: 100,\n    D: 500,\n    M: 1000,\n  };\n\n  let count = 0;\n  let RE = new RegExp(Object.keys(dict).join(\"|\"), \"g\");\n  s.replace(RE, function (matched) {\n    count += dict[matched];\n  });\n  return count;\n};\n```\n\n**2. Update CPU decision logic**\n\nI had initially also wanted to create a toggle to allow players to modify the difficulty of the game. At base, the CPU would always be aware of bad (grey) letters.\n\n- `Easy mode`: CPU knows placed (green) letters only. But not the placement of green letters.\n- `Medium mode`: CPU knows green and valid (yellow) letters. It would also know the placement of green letters, but not yellow letters.\n- `Hard mode`: CPU has the same knowledge as players: green and yellow letters, as well as their placement are known to CPU.\n\nIn the current iteration of the game, the sorting algorithm only receives information regarding the validity of the letters. It does not receive information about their placement. I would need to refactor the sorting algorithms to include placement (indices) in the calculation, as well as split the algorithm into multiple parts/ write separate functions to accommodate switching game modes.\n\nThis might also increase computation load, particularly if I expanded the dictionary in future. Therefore I would need to ensure that the time complexity of such sorting algorithms are taken into account.\n\n**3. Allow Players to Submit Words**\n\nThe word dictionary was borrowed and refined from [dracos' gist](https://gist.github.com/dracos/dd0668f281e685bad51479e5acaadb93). Wardle test players (aka my dear frineds) flagged some notable issues:\n\n    - Lots of scrabble words were included (which makes the game feel 'unfair')\n    - Common plural versions of words (e.g. pains, prays, hopes) were previously missing from the list ((these have since been added)).\n\nIf I could set up a cheap database (e.g. using Gsheets/Airtable + Sheety api) and make a basic form for users to submit requests to add/ remove words, the overall quality of the word base would improve over time as people used it.\n\n**4. Moonshot plans**\n\nPerhaps use Wardle as a base project to build a python machine learning project on top of. The game could then be expanded beyond just copying Wordle's base mechanics (e.g. 5 letters) to possibly include more letters or even incorporate more unique features such as themed tourneys (e.g. given the theme 'cocktails', only cocktail names with a certain number of letters are valid guesses).\n","frontmatter":{"demo":"https://kiittsunne.github.io/wardle/index.html","github":"https://github.com/kiittsunne/wardle","title":"Wardle","byline":"Turn-based Wordle clone built on HTML, CSS, JS","technologies":["HTML","CSS","JavaScript","DOM Manipulation"]}}},"pageContext":{"id":"90b1bef5-c13c-5ca8-ab2f-6a1633f01763","frontmatter__slug":"wardle","__params":{"frontmatter__slug":"wardle"},"frontmatter":{"title":"Wardle","byline":"Turn-based Wordle clone built on HTML, CSS, JS","slug":"wardle","description":"A Wordle clone where players race against a cpu to guess the word of the day. HTML, CSS & vanilla JS. A project made as part of the completion requirements of the General Assembly Software Engineering Intensive. ","technologies":["HTML","CSS","JavaScript","DOM Manipulation"],"github":"https://github.com/kiittsunne/wardle","demo":"https://kiittsunne.github.io/wardle/index.html","published":true,"id":2}}},"staticQueryHashes":[]}